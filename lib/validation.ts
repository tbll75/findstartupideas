import { z } from "zod";

/**
 * Shared Zod schemas for search input and output.
 * These act as the contract between the frontend, API routes,
 * database layer, and any caching layer.
 */

// ============================================================================
// ENUMS
// ============================================================================

export const timeRangeEnum = z.enum(["week", "month", "year", "all"]);
export const sortByEnum = z.enum(["relevance", "upvotes", "recency"]);
export const hnTagsEnum = z.enum([
  "story",
  "ask_hn",
  "show_hn",
  "front_page",
  "poll",
]);
export const statusEnum = z.enum([
  "pending",
  "processing",
  "completed",
  "failed",
]);

// ============================================================================
// REQUEST SCHEMAS
// ============================================================================

export const SearchRequestSchema = z
  .object({
    topic: z
      .string()
      .min(2, "Topic must be at least 2 characters long")
      .max(100, "Topic must be at most 100 characters long")
      .transform((value) => value.trim())
      .refine((value) => value.length > 0, {
        message: "Topic cannot be empty",
      })
      .refine((value) => !/[<>{}[\]\\]/.test(value), {
        message: "Topic contains invalid characters",
      }),
    // Make tags required at the type level (with a runtime default of [])
    // so that downstream consumers don't need to handle `undefined`.
    tags: z
      .array(hnTagsEnum)
      .max(10, "You can specify at most 10 tags")
      .default([]),
    timeRange: timeRangeEnum.default("month"),
    minUpvotes: z
      .number()
      .int()
      .min(0, "Minimum upvotes cannot be negative")
      .max(10000, "Minimum upvotes is too large")
      .default(0),
    sortBy: sortByEnum.default("relevance"),
  })
  .strict();

export type SearchRequest = z.infer<typeof SearchRequestSchema>;

// ============================================================================
// RESPONSE SCHEMAS
// ============================================================================

/**
 * Pain point as stored in database and returned to frontend
 */
export const PainPointSchema = z.object({
  id: z.string().uuid(),
  searchId: z.string().uuid(),
  title: z.string(),
  sourceTag: z.string(),
  mentionsCount: z.number().int().nonnegative(),
  severityScore: z.number().min(0).max(10).optional(),
});

export type PainPoint = z.infer<typeof PainPointSchema>;

/**
 * Quote supporting a pain point
 */
export const PainPointQuoteSchema = z.object({
  id: z.string().uuid(),
  painPointId: z.string().uuid(),
  quoteText: z.string(),
  authorHandle: z.string().nullable(),
  upvotes: z.number().int().nonnegative(),
  permalink: z.string().url(),
});

export type PainPointQuote = z.infer<typeof PainPointQuoteSchema>;

/**
 * Product idea generated by AI
 * MATCHES Gemini output format from Edge Function
 */
export const ProductIdeaSchema = z.object({
  title: z.string(),
  description: z.string(),
  targetProblem: z.string(), // Which pain point this solves
  impactScore: z.number().min(0).max(10),
});

export type ProductIdea = z.infer<typeof ProductIdeaSchema>;

/**
 * Problem cluster from Gemini analysis
 * MATCHES Gemini output format from Edge Function
 */
export const ProblemClusterSchema = z.object({
  title: z.string(),
  description: z.string(),
  severity: z.number().min(0).max(10), // Changed from severityScore to match Gemini
  mentionCount: z.number().int().nonnegative(), // Changed from optional to required
  examples: z.array(z.string()), // Added - Gemini returns quote examples
});

export type ProblemCluster = z.infer<typeof ProblemClusterSchema>;

/**
 * Complete AI analysis response
 */
export const AiAnalysisSchema = z.object({
  summary: z.string(),
  problemClusters: z.array(ProblemClusterSchema),
  productIdeas: z.array(ProductIdeaSchema),
  model: z.string().optional(),
  tokensUsed: z.number().int().nonnegative().optional(),
});

export type AiAnalysis = z.infer<typeof AiAnalysisSchema>;

/**
 * Full assembled search result returned by API and stored in Redis
 */
export const SearchResultSchema = z.object({
  searchId: z.string().uuid(),
  status: statusEnum,
  topic: z.string(),
  tags: z.array(hnTagsEnum),
  timeRange: timeRangeEnum,
  minUpvotes: z.number().int().min(0),
  sortBy: sortByEnum,
  totalMentions: z.number().int().nonnegative().optional(),
  totalPostsConsidered: z.number().int().nonnegative().optional(),
  totalCommentsConsidered: z.number().int().nonnegative().optional(),
  sourceTags: z.array(z.string()).optional(),
  painPoints: z.array(PainPointSchema),
  quotes: z.array(PainPointQuoteSchema),
  analysis: AiAnalysisSchema.optional(),
});

export type SearchResult = z.infer<typeof SearchResultSchema>;

// ============================================================================
// API RESPONSE SCHEMAS
// ============================================================================

/**
 * Response from POST /api/search (immediate response)
 */
export const SearchInitiatedResponseSchema = z.object({
  searchId: z.string().uuid(),
  status: statusEnum,
  message: z.string().optional(),
});

export type SearchInitiatedResponse = z.infer<
  typeof SearchInitiatedResponseSchema
>;

/**
 * Response from GET /api/search-status?searchId=...
 */
export const SearchStatusResponseSchema = z.discriminatedUnion("status", [
  z.object({
    status: z.literal("pending"),
    searchId: z.string().uuid(),
    message: z.string().optional(),
  }),
  z.object({
    status: z.literal("processing"),
    searchId: z.string().uuid(),
    progress: z.number().min(0).max(100).optional(),
    message: z.string().optional(),
  }),
  z.object({
    status: z.literal("completed"),
    searchId: z.string().uuid(),
    result: SearchResultSchema,
  }),
  z.object({
    status: z.literal("failed"),
    searchId: z.string().uuid(),
    error: z.string(),
  }),
]);

export type SearchStatusResponse = z.infer<typeof SearchStatusResponseSchema>;

// ============================================================================
// DATABASE ROW SCHEMAS (for type safety when reading from Supabase)
// ============================================================================

/**
 * Matches the `searches` table row
 */
export const SearchRowSchema = z.object({
  id: z.string().uuid(),
  created_at: z.string().datetime(),
  completed_at: z.string().datetime().nullable(),
  topic: z.string(),
  subreddits: z.array(z.string()).nullable(),
  time_range: timeRangeEnum,
  min_upvotes: z.number().int(),
  sort_by: sortByEnum,
  client_fingerprint: z.string().nullable(),
  status: statusEnum,
  error_message: z.string().nullable(),
  retry_count: z.number().int().default(0),
  last_retry_at: z.string().datetime().nullable(),
  next_retry_at: z.string().datetime().nullable(),
});

export type SearchRow = z.infer<typeof SearchRowSchema>;

/**
 * Matches the `search_results` table row
 */
export const SearchResultsRowSchema = z.object({
  id: z.string().uuid(),
  search_id: z.string().uuid(),
  total_mentions: z.number().int().nullable(),
  total_posts_considered: z.number().int().nullable(),
  total_comments_considered: z.number().int().nullable(),
  source_subreddits: z.array(z.string()).nullable(),
  source_tags: z.array(z.string()).nullable(),
});

export type SearchResultsRow = z.infer<typeof SearchResultsRowSchema>;

/**
 * Matches the `pain_points` table row
 */
export const PainPointRowSchema = z.object({
  id: z.string().uuid(),
  search_id: z.string().uuid(),
  title: z.string(),
  subreddit: z.string(),
  mentions_count: z.number().int(),
  severity_score: z.number().nullable(),
});

export type PainPointRow = z.infer<typeof PainPointRowSchema>;

/**
 * Matches the `pain_point_quotes` table row
 */
export const PainPointQuoteRowSchema = z.object({
  id: z.string().uuid(),
  pain_point_id: z.string().uuid(),
  quote_text: z.string(),
  author_handle: z.string().nullable(),
  upvotes: z.number().int(),
  permalink: z.string(),
});

export type PainPointQuoteRow = z.infer<typeof PainPointQuoteRowSchema>;

/**
 * Matches the `ai_analyses` table row
 */
export const AiAnalysisRowSchema = z.object({
  id: z.string().uuid(),
  search_id: z.string().uuid(),
  summary: z.string(),
  problem_clusters: z.unknown(), // JSONB - will be parsed with ProblemClusterSchema
  product_ideas: z.unknown(), // JSONB - will be parsed with ProductIdeaSchema
  model: z.string().nullable(),
  tokens_used: z.number().int().nullable(),
  created_at: z.string().datetime().optional(),
});

export type AiAnalysisRow = z.infer<typeof AiAnalysisRowSchema>;

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Safely parse unknown data with Zod schema and return null on failure
 */
export function safeParse<T>(schema: z.ZodSchema<T>, data: unknown): T | null {
  const result = schema.safeParse(data);
  if (result.success) {
    return result.data;
  }
  console.error("Zod validation failed:", result.error);
  return null;
}

/**
 * Parse and validate Gemini's JSONB problem_clusters from database
 */
export function parseProblemClusters(raw: unknown): ProblemCluster[] {
  if (!Array.isArray(raw)) return [];
  return raw
    .map((item) => safeParse(ProblemClusterSchema, item))
    .filter((item): item is ProblemCluster => item !== null);
}

/**
 * Parse and validate Gemini's JSONB product_ideas from database
 */
export function parseProductIdeas(raw: unknown): ProductIdea[] {
  if (!Array.isArray(raw)) return [];
  return raw
    .map((item) => safeParse(ProductIdeaSchema, item))
    .filter((item): item is ProductIdea => item !== null);
}

/**
 * Build search key for Redis/cache lookup
 */
export function buildSearchKey(input: SearchRequest): string {
  const normalized = {
    topic: input.topic.toLowerCase().trim(),
    tags: [...input.tags].sort(),
    timeRange: input.timeRange,
    minUpvotes: input.minUpvotes,
    sortBy: input.sortBy,
  };
  return `searchKey:${JSON.stringify(normalized)}`;
}

/**
 * Validate and sanitize search request from user
 */
export function validateSearchRequest(input: unknown): SearchRequest | null {
  const parsed = safeParse(SearchRequestSchema, input);
  if (!parsed) return null;

  // Normalize to a fully-populated `SearchRequest` so callers never need to
  // handle `undefined` or missing fields, even if the schema's input type
  // allows them (because of defaults).
  return {
    topic: parsed.topic,
    tags: parsed.tags ?? [],
    timeRange: parsed.timeRange ?? "month",
    minUpvotes: parsed.minUpvotes ?? 0,
    sortBy: parsed.sortBy ?? "relevance",
  };
}

/**
 * Validate search result before caching or returning to frontend
 */
export function validateSearchResult(data: unknown): SearchResult | null {
  return safeParse(SearchResultSchema, data);
}

// ============================================================================
// TYPE GUARDS
// ============================================================================

export function isCompleted(
  response: SearchStatusResponse
): response is Extract<SearchStatusResponse, { status: "completed" }> {
  return response.status === "completed";
}

export function isFailed(
  response: SearchStatusResponse
): response is Extract<SearchStatusResponse, { status: "failed" }> {
  return response.status === "failed";
}

export function isProcessing(
  response: SearchStatusResponse
): response is Extract<SearchStatusResponse, { status: "processing" }> {
  return response.status === "processing";
}

export function isPending(
  response: SearchStatusResponse
): response is Extract<SearchStatusResponse, { status: "pending" }> {
  return response.status === "pending";
}
